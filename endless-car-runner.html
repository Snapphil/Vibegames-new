<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endless Car Runner 3D</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(180deg, #87CEEB 0%, #98FB98 100%);
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 100;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 100;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            font-size: 32px;
            font-weight: bold;
            z-index: 1000;
            display: none;
        }

        .button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 10px 5px;
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.3s;
        }

        .button:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui">
            <div>Score: <span id="score">0</span></div>
            <div>Speed: <span id="speed">0</span> km/h</div>
        </div>

        <div id="instructions">
            <div>Use ARROW KEYS to move left/right</div>
            <div>Avoid red obstacles!</div>
        </div>

        <div id="game-over">
            <div>Game Over!</div>
            <div>Final Score: <span id="final-score">0</span></div>
            <button class="button" onclick="restartGame()">Play Again</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game variables
        let scene, camera, renderer, car, track = [], obstacles = [];
        let keys = {};
        let score = 0;
        let speed = 0;
        let gameRunning = true;
        let trackSpeed = 0.5;
        let carPosition = { x: 0, z: 0 };
        let cameraOffset = { x: 0, y: 5, z: -8 };

        // Initialize the game
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(cameraOffset.x, cameraOffset.y, cameraOffset.z);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Create car
            createCar();

            // Create initial track
            createTrack();

            // Create initial obstacles
            createObstacles();

            // Add event listeners
            window.addEventListener('keydown', (e) => keys[e.code] = true);
            window.addEventListener('keyup', (e) => keys[e.code] = false);
            window.addEventListener('resize', onWindowResize);

            // Start game loop
            animate();
        }

        function createCar() {
            // Car body
            const carBodyGeometry = new THREE.BoxGeometry(1.5, 0.8, 3);
            const carBodyMaterial = new THREE.MeshLambertMaterial({ color: 0xFF0000 });
            const carBody = new THREE.Mesh(carBodyGeometry, carBodyMaterial);
            carBody.position.y = 0.4;
            carBody.castShadow = true;

            // Car cabin
            const cabinGeometry = new THREE.BoxGeometry(1.2, 0.6, 1.5);
            const cabinMaterial = new THREE.MeshLambertMaterial({ color: 0x0000FF });
            const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
            cabin.position.y = 1.1;
            cabin.position.z = -0.3;

            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 8);
            const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });

            const wheels = [];
            const wheelPositions = [
                [-0.6, 0.3, 0.8], [0.6, 0.3, 0.8],  // Front wheels
                [-0.6, 0.3, -0.8], [0.6, 0.3, -0.8]  // Back wheels
            ];

            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos[0], pos[1], pos[2]);
                wheel.rotation.z = Math.PI / 2;
                wheel.castShadow = true;
                wheels.push(wheel);
            });

            // Car group
            car = new THREE.Group();
            car.add(carBody);
            car.add(cabin);
            wheels.forEach(wheel => car.add(wheel));

            car.position.set(0, 0, 0);
            scene.add(car);
        }

        function createTrack() {
            // Create road segments
            for (let i = 0; i < 20; i++) {
                const roadGeometry = new THREE.PlaneGeometry(10, 2);
                const roadMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const road = new THREE.Mesh(roadGeometry, roadMaterial);
                road.rotation.x = -Math.PI / 2;
                road.position.z = i * 2 - 20;
                road.receiveShadow = true;
                track.push(road);
                scene.add(road);

                // Road markings
                const markingGeometry = new THREE.PlaneGeometry(0.2, 2);
                const markingMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
                const marking = new THREE.Mesh(markingGeometry, markingMaterial);
                marking.rotation.x = -Math.PI / 2;
                marking.position.set(0, 0.01, i * 2 - 20);
                scene.add(marking);
            }

            // Add grass on sides
            for (let i = 0; i < 20; i++) {
                const grassGeometry = new THREE.PlaneGeometry(20, 2);
                const grassMaterial = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
                const grassLeft = new THREE.Mesh(grassGeometry, grassMaterial);
                const grassRight = new THREE.Mesh(grassGeometry, grassMaterial);

                grassLeft.rotation.x = -Math.PI / 2;
                grassRight.rotation.x = -Math.PI / 2;

                grassLeft.position.set(-15, 0, i * 2 - 20);
                grassRight.position.set(15, 0, i * 2 - 20);

                scene.add(grassLeft);
                scene.add(grassRight);
            }
        }

        function createObstacles() {
            // Create some initial obstacles
            for (let i = 0; i < 10; i++) {
                addObstacle(i * 15 + 10);
            }
        }

        function addObstacle(zPosition) {
            const obstacleGeometry = new THREE.BoxGeometry(1, 1, 1);
            const obstacleMaterial = new THREE.MeshLambertMaterial({ color: 0xFF0000 });
            const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
            obstacle.castShadow = true;

            // Random lane position
            const lanes = [-3, 0, 3];
            const lane = lanes[Math.floor(Math.random() * lanes.length)];
            obstacle.position.set(lane, 0.5, zPosition);

            obstacles.push(obstacle);
            scene.add(obstacle);
        }

        function moveTrack() {
            track.forEach(segment => {
                segment.position.z += trackSpeed;

                // Reset segment when it goes too far
                if (segment.position.z > 20) {
                    segment.position.z -= 40;
                }
            });

            // Move obstacles
            obstacles.forEach((obstacle, index) => {
                obstacle.position.z += trackSpeed;

                // Remove obstacles that are too far behind
                if (obstacle.position.z > 30) {
                    scene.remove(obstacle);
                    obstacles.splice(index, 1);
                    score += 10;
                    document.getElementById('score').textContent = score;
                }
            });

            // Add new obstacles occasionally
            if (Math.random() < 0.02) {
                addObstacle(-30);
            }
        }

        function updateCar() {
            const moveSpeed = 0.3;

            // Move car based on input
            if (keys['ArrowLeft'] && car.position.x > -4) {
                car.position.x -= moveSpeed;
            }
            if (keys['ArrowRight'] && car.position.x < 4) {
                car.position.x += moveSpeed;
            }

            // Update camera to follow car
            camera.position.x = car.position.x + cameraOffset.x;
            camera.position.z = car.position.z + cameraOffset.z;
            camera.lookAt(car.position.x, car.position.y + 1, car.position.z);

            // Check collisions
            checkCollisions();
        }

        function checkCollisions() {
            obstacles.forEach(obstacle => {
                const carBox = new THREE.Box3().setFromObject(car);
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);

                if (carBox.intersectsBox(obstacleBox)) {
                    gameOver();
                }
            });
        }

        function gameOver() {
            gameRunning = false;
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over').style.display = 'block';
        }

        function restartGame() {
            // Reset game state
            score = 0;
            speed = 0;
            gameRunning = true;

            // Reset car position
            car.position.set(0, 0, 0);

            // Clear obstacles
            obstacles.forEach(obstacle => scene.remove(obstacle));
            obstacles = [];

            // Recreate initial obstacles
            createObstacles();

            // Hide game over screen
            document.getElementById('game-over').style.display = 'none';

            document.getElementById('score').textContent = score;
            document.getElementById('speed').textContent = speed;
        }

        function animate() {
            requestAnimationFrame(animate);

            if (gameRunning) {
                moveTrack();
                updateCar();

                // Increase speed over time
                speed = Math.min(speed + 0.1, 100);
                trackSpeed = 0.5 + (speed / 100) * 1.5;

                document.getElementById('speed').textContent = Math.floor(speed);
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start the game
        init();
    </script>
</body>
</html>
